using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_2.malware_daemons;
using dotnet_cyberpunk_challenge_2.malware_daemons.lib;

namespace dotnet_cyberpunk_challenge_2
{
    public static class HandleTheMalware
    {
        public static async Task HandleMalwareChallenges() {
            await Challenge1();
            await Challenge2();
            await Challenge3();
            Challenge4();
        }

        private static async Task Challenge1() {
            // Objective: You've been tasked by a hacker cell to build out the beginnings of our IceBreaker Malware to attack Arasaka
            // There's a couple pieces missing though. The Ice Breaker needs to be an instance of our
            // Kuang Grade Eleven malware. See if you build it out and print out some info from it for diagnostics

            /*TODO: hmm something is missing*/ iceBreaker = new /*TODO: Need to make an instance of the Kuang Grade Eleven Malware*/
            
            
            // We need to call a function to get the current Arasaka Connection. 
            // Look around in the iceBreaker's class or it's parent class to see what we can use.
            // *Hint*: Click on the Class for iceBreaker and use F12 to go immediately to that class definition.
            // If the functions on the class don't appear to be helpful then use F12 to view the parent's class as well.
            ArasakaMessageResponse message = await iceBreaker./*TODO: Something is missing. Need to Get the Current Server Connection*/;

            // TODO: 
            // Since we got the message back from Arasaka from that function we should check out some of the properties on it
            // Go ahead and print out some of the properties on Arasaka Message, NOTE: We've already done that for messageId:
            // - messageId
            // - arasakaServer
            // - netwatchMonitored
            Console.WriteLine(message.metadata["messageId"]);

            // There are a couple properties in the content property we want to print out as well
            // So do the same as you did with message.metadata except you'll use message.content.
            // TODO: Print the following properties from message.content
            // - accessKey
            // - isAuthenticated
            // - isEncrypted
            // - TTL
            // - message
            Console.WriteLine(message./*TODO: something missing*/);

            
            // Once we have the connection established we need to print out some details about the connection
            // See if you can print out the following properties:
            /*
                - connection ID
                - Desitnation Address
                - Source Address
                - ProcessId
            */
            Console.WriteLine(iceBreaker.CurrentServerConnection./*TODO*/);
        }

        private static async Task Challenge2 () {
            // Objective: Now that we know how to build the Kuang Grade Eleven and establish a connection
            // to Arasaka we need to build a secure tunnel to the Server.
            // You'll need to build another Kuang Grade Eleven and use one of it's built in functions
            // to establish a secure tunnel.


            /*TODO: Missing something...*/ iceBreaker = new /*TODO: Missing something...*/;


            // You'll need to look at the class of your iceBreaker by using F12 and look at it's public functions.
            // One of them should allow us to Setup a Tunnel To The Target.
            await iceBreaker./*TODO: Hmm...what function to us??*/;

            // We need to print out the following properties to ensure our tunnel is setup properly:
            //     - connection ID
            //     - Desitnation Address
            //     - Source Address
            //     - ProcessId
            //     - IsEncrypted
            //     - TunnelEncryption (this might be tricky :) )
            Console.WriteLine(iceBreaker.CurrentIceBreakerTunnelConnection./*TODO: something is missing, maybe more than one*/)

        }

        private static void Challenge3() {
            // Objective: We know what GetIceTypeOnRemote() is going to return to us and we know what it's gonna be overridden
            // but now we actually need to go implement how it works. Another operator has given you some basic code but you'll
            // need to write the logic of detecting the ICE model that we're dealing with.
            
            // TODO: This function doesn't do anything so go to the Kuang Grade Eleven and do some work there.
        }

        private static async Task Challenge4 () {
            // Objective: In order for us to break the ICE later we need to know a couple things about it first!
            // One of those things is obviously going to be...what type of ICE are we dealing with?
            // There should be a function in the Kuang Grade Eleven class that we can use to get the model type.

            // Guess what? Gotta make another ice breaker, but this time from scratch :)
            /*TODO: Put your iceBreaker instantiation here. MAKE SURE to call it iceBreaker just like above*/

            // We need to call a function that will get the type of ICE on the remote host.
            // See if you can check out the Kuang class and find a public function that'll do that for us
            ArasakaMessageResponse iceTypeMessage = await iceBreaker./*TODO: What function goes here?*/
            // TODO: We'll need to actually print out the model type and metadata of the message. Here's the properties print out:
            // These properties are in the iceTypeMessage.content 
            // - accessKey
            // - isAuthenticated
            // - isEncrypted
            // - TTL
            // - message
        
            // These properties are on the iceTypeMessage.metadata
            // - messageId
            // - arasakaServer
            // - netwatchMonitored
            Console.WriteLine(iceTypeMessage.content);
        }
    }
}